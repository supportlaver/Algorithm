# dp[j] 가 의미하는 것 : 가방에 j 무게 만큼 담았을 때 보석의 최대 가치를 저장

# 총 4개의 보석이 주어지고 11kg 의 무게까지 담을 수 있다고 가정해보자. 
# 5kg 12 가치 , 3kg 8 가치 ... 의 보석이 주어진다.
# 이때 5kg 12 가치의 보석만 있다고 생각하고 진행한다.
# 그렇다면 dp[5] = 12 를 넣으면 되는데, 이때 dp[5-5] 도 확인을 한다.
# 확인하는 이유는 계속 진행해볼 때 알 수 있다.
# dp[6] 의 의미를 생각해보면 6kg 무게 만큼 담았을 때 보석의 최대 가치를 저장하는 것인데,
# 현재 5kg 의 보석만이 있다고 하니 5kg 는 이미 차지했고 남은 1kg 에 담을 보석이 있는지 확인하면 된다.
# 그래서 dp[6] 의 값을 넣을 때 5kg 가치인 12 + dp[1] 의 값을 넣어준다.
# 현재 1kg 의 가치를 가진 보석은 없기 떄문에 0 이 들어있어 dp[6] 에도 12 가 들어간다.
# 계속 반복을 하다가 dp[10] 을 채울 때 생각해보면 먼저 5kg 를 채웠으니 5kg 가 남게 되고,
# 그 최대 가치는 dp[5] 에 저장되어 있으니 12 + dp[5] 값이 dp[10] 에 저장된다.

n,m = map(int,input().split())
jewel = []
for _ in range(n):
    w,v = map(int,input().split())
    jewel.append((v,w))
dp = [0] * (m+1)

for i in range(n):
    w = jewel[i][0]
    v = jewel[i][1]
    for j in range(w,m+1):
        # 최대 가치를 가지는 경우를 봐야하기 때문에 기존의 경우보다 큰 가치를 가질 때만 새로운 값으로 갱신해준다.
        if (dp[j] < dp[j-w]+v):
            dp[j] = dp[j-w]+v

print(dp[m])
        




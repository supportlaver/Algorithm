# 그동안 해왔던 냅색 알고리즘과는 다르게 한 유형당 한 개만 풀 수 있다는 조건이 있다.
# dy[i][j] 가 의미하는 것은 ?
# i번째 까지 문제를 풀었을 때 j 시간동안 얻을 수 있는 최대 점수를 넣는다.
# dy[3][15] 면 3번째 문제까지 풀었을때 , 15 분 동안 얻을 수 있는 최대 점수
# 2차원 테이블로 한 이유는 한 개씩만 문제를 풀 수 있기 때문이다.

# 하지만 2차원 테이블로 하게 되면 문제의 개수와 제한 시간이 최대로 주어지면 메모리를 많이 차지하고
# 시간도 오래 걸리게 된다. (또한 2차원으로 풀 때 보다 1차원으로 해결하는 것이 더 내공이 있어보인다..ㅎ)

# 현재 1차원으로 풀 때 문제는 문제를 중복해서 푼다는 것 이다.
# 이것을 해결하기 위한 방법은 앞에서부터 시작하는 것이 아니라 뒤에서부터 시작하고 감소하면서 앞으로 가면 된다.

n,m = map(int,input().split())
a = []
for _ in range(n):
    a.append(tuple(map(int,input().split())))
dp = [0] * (m+1)

for i in range(n):
    pv = a[i][0]
    pt = a[i][1]
    # 뒤에서부터 -1 씩 감소하게 되면, 중복해서 푸는 경우가 없어진다.
    for j in range(m,pt-1,-1):
        dp[j] = max(dp[j], pv+dp[j-pt])
print(dp[m])
